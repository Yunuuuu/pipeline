% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/class-Pipeline.R
\name{Pipeline}
\alias{Pipeline}
\title{R6 Class Representing Pipeline}
\description{
A Pipeline object, is bound with two environment, of which one
for the collections of steps (step_collections) and another for the
accommodation of objects to run steps or the objects returned by the steps.

In this way, we can bind all steps used in a pipeline and their dependant
evaluation frame in one object.
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-Pipeline-new}{\code{Pipeline$new()}}
\item \href{#method-Pipeline-set_step_collections}{\code{Pipeline$set_step_collections()}}
\item \href{#method-Pipeline-get_step}{\code{Pipeline$get_step()}}
\item \href{#method-Pipeline-get_step_list}{\code{Pipeline$get_step_list()}}
\item \href{#method-Pipeline-add_steps}{\code{Pipeline$add_steps()}}
\item \href{#method-Pipeline-remove_steps}{\code{Pipeline$remove_steps()}}
\item \href{#method-Pipeline-reset_steps}{\code{Pipeline$reset_steps()}}
\item \href{#method-Pipeline-reset_step_collections}{\code{Pipeline$reset_step_collections()}}
\item \href{#method-Pipeline-finish_steps}{\code{Pipeline$finish_steps()}}
\item \href{#method-Pipeline-modify_step}{\code{Pipeline$modify_step()}}
\item \href{#method-Pipeline-modify_call}{\code{Pipeline$modify_call()}}
\item \href{#method-Pipeline-get_step_graph}{\code{Pipeline$get_step_graph()}}
\item \href{#method-Pipeline-plot_step_graph}{\code{Pipeline$plot_step_graph()}}
\item \href{#method-Pipeline-run_step}{\code{Pipeline$run_step()}}
\item \href{#method-Pipeline-run_targets}{\code{Pipeline$run_targets()}}
\item \href{#method-Pipeline-env_get}{\code{Pipeline$env_get()}}
\item \href{#method-Pipeline-env_get_list}{\code{Pipeline$env_get_list()}}
\item \href{#method-Pipeline-env_bind}{\code{Pipeline$env_bind()}}
\item \href{#method-Pipeline-env_unbind}{\code{Pipeline$env_unbind()}}
\item \href{#method-Pipeline-env_move}{\code{Pipeline$env_move()}}
\item \href{#method-Pipeline-env_names}{\code{Pipeline$env_names()}}
\item \href{#method-Pipeline-clone}{\code{Pipeline$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-new"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-new}{}}}
\subsection{Method \code{new()}}{
Create a new person object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$new(..., data = list())}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{<\code{\link[rlang:dyn-dots]{dynamic-dots}}> all items must be a \code{step}
object. Names won't make any sense. Any duplicated steps (with duplicated
id) are only included once, the latter one will override the former. Can
also provide as a list of steps directly.}

\item{\code{data}}{A data list to build the attached environment which is
used to evaluate the variable in the step expression object. One
can also use \verb{$env_bind} method to add new variable.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new \code{Pipeline} object.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-set_step_collections"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-set_step_collections}{}}}
\subsection{Method \code{set_step_collections()}}{
Set the step tree in the \code{Pipeline} object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$set_step_collections(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{<\code{\link[rlang:dyn-dots]{dynamic-dots}}> all items must be a \code{step}
object. Names won't make any sense. Any duplicated steps (with duplicated
id) are only included once, the latter one will override the former. Can
also provide as a list of steps directly.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-get_step"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-get_step}{}}}
\subsection{Method \code{get_step()}}{
Get a single step in the \code{Pipeline} step_collections.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$get_step(id)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{id}}{A scalar character of the step name.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A step object.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-get_step_list"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-get_step_list}{}}}
\subsection{Method \code{get_step_list()}}{
Get multiple steps in the \code{Pipeline} step_collections.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$get_step_list(ids = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{ids}}{An atomic character of the step name. if \code{NULL}, all steps
will be extracted.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of step object.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-add_steps"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-add_steps}{}}}
\subsection{Method \code{add_steps()}}{
Add new steps into the \code{Pipeline} step_collections.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$add_steps(..., reset = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{<\code{\link[rlang:dyn-dots]{dynamic-dots}}> all items must be a \code{step}
object. Names won't make any sense. Any duplicated steps (with duplicated
id) are only included once, the latter one will override the former. Can
also provide as a list of steps directly.}

\item{\code{reset}}{If \code{TRUE}, will label all downstream steps (depend on current
step) as unfinished.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-remove_steps"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-remove_steps}{}}}
\subsection{Method \code{remove_steps()}}{
Remove steps in the \code{Pipeline} step_collections.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$remove_steps(ids, reset = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{ids}}{An atomic character, the steps to remove from the
\code{Pipeline}.}

\item{\code{reset}}{If \code{TRUE}, will label all downstream steps (depend on current
step) as unfinished.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-reset_steps"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-reset_steps}{}}}
\subsection{Method \code{reset_steps()}}{
Label the step as unfinished. If downstream is \code{TRUE},
will also label all steps depending on this step as unfinished.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$reset_steps(ids, downstream = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{ids}}{An atomic character, the steps to reset.}

\item{\code{downstream}}{If \code{TRUE}, will label all downstream steps (depend
on current step) as unfinished.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-reset_step_collections"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-reset_step_collections}{}}}
\subsection{Method \code{reset_step_collections()}}{
Label all steps in the \code{step_collections} as unfinished.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$reset_step_collections()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-finish_steps"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-finish_steps}{}}}
\subsection{Method \code{finish_steps()}}{
Label the step as finished.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$finish_steps(ids)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{ids}}{Should be an atomic character, the steps used to form the step
dependencies graph, this is passed into the \code{vids} argument of
\link[igraph:subgraph]{subgraph}. Only one or none of "to", "from", "ids" can be
specified. If all "ids", "from" and "to" arguments are \code{NULL}, the whole
step_collections in the pipeline will be used to create the dependencies
graph.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-modify_step"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-modify_step}{}}}
\subsection{Method \code{modify_step()}}{
Modify the step components.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$modify_step(id, ..., reset = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{id}}{A scalar character of the step name.}

\item{\code{...}}{<\code{\link[rlang:dyn-dots]{dynamic-dots}}>, A named value paris
indicates the components to replace in the \code{step}. \code{NULL} will be
kept, use \code{\link[=zap]{zap()}} to remove a component from the step.}

\item{\code{reset}}{If \code{TRUE}, will label all downstream steps (depend on current
step) as unfinished.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-modify_call"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-modify_call}{}}}
\subsection{Method \code{modify_call()}}{
If the expression in the step is a \code{call} object, this provide a
convenient way to modify the call argument.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$modify_call(id, ..., reset = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{id}}{A scalar character of the step name.}

\item{\code{...}}{<\code{\link[rlang:dyn-dots]{dynamic-dots}}>, Named or unnamed
expressions (constants, names or calls) used to modify the call.
Use \code{\link[=zap]{zap()}} to remove arguments. Empty arguments are preserved.}

\item{\code{reset}}{If \code{TRUE}, will label all downstream steps (depend on current
step) as unfinished.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-get_step_graph"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-get_step_graph}{}}}
\subsection{Method \code{get_step_graph()}}{
Build step dependencies network as an graph object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$get_step_graph(to = NULL, from = NULL, ids = NULL, add_attrs = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{to}}{The step to start the search to create the step dependencies graph.
If \code{to} is specified, all steps from which the (to) step is reachable are
extracted. Only one or none of "to", "from", "ids" can be specified.}

\item{\code{from}}{The step to start the search to create the step dependencies
graph. If \code{from} is specified, all steps reachable from the (from) step are
extracted. Only one or none of "to", "from", "ids" can be specified.}

\item{\code{ids}}{Should be an atomic character, the steps used to form the step
dependencies graph, this is passed into the \code{vids} argument of
\link[igraph:subgraph]{subgraph}. Only one or none of "to", "from", "ids" can be
specified. If all "ids", "from" and "to" arguments are \code{NULL}, the whole
step_collections in the pipeline will be used to create the dependencies
graph.}

\item{\code{add_attrs}}{If \code{TRUE}, add "is_finished", "is_existed" and
"step_levels" as the graph vertex attributes. Default: \code{FALSE}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A igraph object.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-plot_step_graph"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-plot_step_graph}{}}}
\subsection{Method \code{plot_step_graph()}}{
Plot the step dependencies tree.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$plot_step_graph(
  to = NULL,
  from = NULL,
  ids = NULL,
  layout = igraph::layout_as_tree,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{to}}{The step to start the search to create the step dependencies graph.
If \code{to} is specified, all steps from which the (to) step is reachable are
extracted. Only one or none of "to", "from", "ids" can be specified.}

\item{\code{from}}{The step to start the search to create the step dependencies
graph. If \code{from} is specified, all steps reachable from the (from) step are
extracted. Only one or none of "to", "from", "ids" can be specified.}

\item{\code{ids}}{Should be an atomic character, the steps used to form the step
dependencies graph, this is passed into the \code{vids} argument of
\link[igraph:subgraph]{subgraph}. Only one or none of "to", "from", "ids" can be
specified. If all "ids", "from" and "to" arguments are \code{NULL}, the whole
step_collections in the pipeline will be used to create the dependencies
graph.}

\item{\code{layout}}{Gives the layout of the graphs.}

\item{\code{...}}{Other arguments passed to \code{\link[igraph:plot.igraph]{plot}}.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-run_step"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-run_step}{}}}
\subsection{Method \code{run_step()}}{
Running the step
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$run_step(id, refresh = FALSE, envir = caller_env())}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{id}}{A scalar character of the step name.}

\item{\code{refresh}}{If \code{TRUE}, the step will be evaluated no matter wether the
step has been finished or not. Otherwise the step will only be evaluated if
it has never been evaluated once, in which case, the result will be obtained
directly from the last evaluated result.}

\item{\code{envir}}{The environment in which to evaluate the \code{expression} in
the step.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-run_targets"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-run_targets}{}}}
\subsection{Method \code{run_targets()}}{
Running the steps until the target step
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$run_targets(targets = NULL, refresh = FALSE, envir = caller_env())}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{targets}}{<\code{\link[tidyselect:language]{tidy-select}}>, A set of
targeted steps until which to run.}

\item{\code{refresh}}{If \code{TRUE}, the step will be evaluated no matter wether the
step has been finished or not. Otherwise the step will only be evaluated if
it has never been evaluated once, in which case, the result will be obtained
directly from the last evaluated result.}

\item{\code{envir}}{The environment in which to evaluate the \code{expression} in
the step.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-env_get"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-env_get}{}}}
\subsection{Method \code{env_get()}}{
Get single variable from the environment
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$env_get(nm)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{nm}}{Name of binding, a string.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-env_get_list"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-env_get_list}{}}}
\subsection{Method \code{env_get_list()}}{
Get multiple variable from the environment
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$env_get_list(nms)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{nms}}{Names of bindings, a character vector.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-env_bind"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-env_bind}{}}}
\subsection{Method \code{env_bind()}}{
Bind symbols to object in the attached environment.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$env_bind(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{<\code{\link[rlang:dyn-dots]{dynamic-dots}}>, Named objects
(env_bind()). Use zap() to remove bindings.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-env_unbind"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-env_unbind}{}}}
\subsection{Method \code{env_unbind()}}{
Remove bindings from the attached environment.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$env_unbind(nms)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{nms}}{A character vector of binding names to remove.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-env_move"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-env_move}{}}}
\subsection{Method \code{env_move()}}{
Move variable from a environment to the attached environment
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$env_move(variable)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{variable}}{A single symbol.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-env_names"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-env_names}{}}}
\subsection{Method \code{env_names()}}{
Names of symbols bound in the attached environment
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$env_names()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-clone"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
